### **Задания к семинару**

---

#### **Задание 1. Сравнение различных методов сглаживания**
1. Считать изображение с ярко выраженным шумом (например, шум «соль и перец» и/или гауссовский шум).  
2. Применить последовательно три фильтра сглаживания: **Box Blur**, **Gaussian Blur** и **Median Blur**.  
3. Для каждого результата визуально оценить, насколько хорошо удалён шум и сохранены детали. Дополнительно, при наличии «чистого» эталона, вычислить метрики MSE или PSNR.  
4. Сравнить, какой метод сглаживания справляется с шумом лучше, и обсудить его влияние на мелкие детали изображения.

---

#### **Задание 2. Усиление резкости методом Unsharp Masking**
1. Выбрать изображение с множеством мелких деталей (текстуры, тонкие линии).  
2. Выполнить гауссовое размытие (например, с ядром 7×7 и \(\sigma\approx2\)).  
3. Реализовать формулу Unsharp Masking: \(\displaystyle I_{\text{sharpened}} = I + \alpha \,(I - I_{\text{blurred}})\), перебирая несколько значений \(\alpha\) (0.5, 1.0, 1.5, 2.0).  
4. Сравнить полученные результаты и отметить появление «ореолов» или артефактов при больших \(\alpha\).

---

#### **Задание 3. Адаптивная пороговая сегментация и морфология**
1. Считать изображение, имеющее неравномерное освещение (например, скан документа с тенями).  
2. Преобразовать в оттенки серого и применить адаптивную пороговую обработку (`cv2.adaptiveThreshold`) с методами `MEAN_C` и `GAUSSIAN_C`.  
3. Полученную бинарную маску очистить морфологической операцией **opening** (эрозия → дилатация) для удаления белых шумовых точек.  
4. Сравнить исходные двоичные изображения и те, что прошли морфологическую очистку. Обсудить, насколько улучшилось качество сегментации.

---

#### **Задание 4. Устранение шума «соль и перец» с помощью медианного фильтра и морфологии**
1. Искуственно добавить к выбранному изображению шум типа «соль и перец» (заменив случайные пиксели на 0 и 255).  
2. Применить медианный фильтр (`cv2.medianBlur`) с ядрами 3×3, 5×5, 7×7 и сравнить результаты.  
3. Преобразовать изображение в бинарное (пороговая сегментация) и попробовать удалить шумовые точки с помощью морфологического **открытия** (разные размеры ядра).  
4. Сравнить оба подхода (чисто медианная фильтрация vs. морфология) и сделать выводы о достоинствах и недостатках каждого в разных сценариях.

---

#### **Задание 5. Выделение контуров с помощью морфологического градиента**
1. Считать бинарное изображение (или получить бинарную маску после порога).  
2. Определить **морфологический градиент** как разницу между дилатированным и эродированным вариантом одной и той же маски.  
3. Сравнить полученный контур с результатами операторов Собеля или Канни (если применяли к исходному изображению).  
4. Проанализировать, в чём заключаются отличия по точности и толщине контуров в каждом случае.

---

#### **Задание 6. Использование Top-hat и Black-hat для поиска мелких деталей**
1. Считать полутоновое (grayscale) изображение с неравномерным фоном.  
2. Применить операции `Top-hat (I - Opening(I))` и `Black-hat (Closing(I) - I)` с ядром 15×15 (или иным размером).  
3. Визуализировать результаты: какие светлые/тёмные «мелкие» элементы были выделены?  
4. Попробовать вычесть полученные карты из исходного изображения, чтобы сгладить фон или убрать мелкие артефакты.

---

#### **Задание 7. Морфологическая реконструкция**
1. Считать изображение (mask) и подготовить «маркер» (marker) — например, эродированную версию mask.  
2. Реализовать пошаговую дилатацию маркера, на каждом шаге ограничивая результат минимальным значением с mask.  
3. Остановиться, когда маркер перестанет изменяться.  
4. Визуализировать итог реконструкции и, при желании, промежуточные шаги. Объяснить, как «реконструкция» отличается от обычной дилатации.

---

#### **Задание 8. Очистка маски при детектировании движущихся объектов**
1. Считать видео или серию кадров, применить алгоритм вычитания фона (например, `cv2.createBackgroundSubtractorMOG2()`).  
2. На полученной бинарной маске выполнить морфологические операции **open** и **close** с ядром 3×3 или 5×5, чтобы убрать одиночные шумовые пиксели и заполнить «разрывы» в силуэте.  
3. Сравнить результаты до и после морфологии, оценить, насколько лучше выделились движущиеся объекты.

---

#### **Задание 9. Измерение производительности разных фильтров и морфологических операций**
1. Выбрать крупное изображение (HD или выше).  
2. Последовательно применить и замерить время (через `cv2.getTickCount()` или аналог):  
   - `cv2.filter2D()` с ядром 5×5,  
   - `cv2.GaussianBlur(ksize=5×5)`,  
   - `cv2.medianBlur(ksize=5)`,  
   - `cv2.morphologyEx` (opening) с ядром 5×5.  
3. Записать и сравнить времена исполнения, сделать вывод о вычислительной сложности каждого метода.

---

#### **Задание 10. Комплексный пайплайн OCR**
1. Выбрать фотографию или скан текста (с неидеальным качеством).  
2. Преобразовать в оттенки серого, выполнить выравнивание гистограммы (EqualizeHist или CLAHE), затем небольшое сглаживание (GaussianBlur).  
3. Применить пороговую сегментацию (Otsu или адаптивную) и при необходимости морфологические операции (open/close), чтобы очистить символы от шума.  
4. Передать итоговую двоичную маску в OCR-систему (например, Tesseract) и сравнить результаты распознавания с исходным изображением. Сделать выводы о влиянии обработки.